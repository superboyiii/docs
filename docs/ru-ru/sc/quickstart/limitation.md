# Ограничения в написании смарт-контрактов 

### Возможности, поддерживаемые NEO на C#

Используя C# для разработки смарт-контрактов, вы не сможете применить весь набор функций C# из-за разницы между NeoVM и Dotnet IL. 

Поскольку NeoVM более компактна, вам придется  компилировать ограниченный набор функций C#/dotnet в файл AVM.

#### Типы данных

NeoVM предоставляет следующие базовые типы данных：

- `ByteArray`
- `Integer`
- `Boolean`
- `Array`
- `Struct`
- `Map`
- `Interface`

Базовые типы данных, которые можно сгенерировать напрямую из  кода AVM, перечислены ниже:

- `ByteArray`（данный тип представляет как  целочисленное, так и булево значения）
- `Array`
- `Struct`
- `Map`

Базовые типы данных C#:

- `Int8 int16 int32 int64 uint8 uint16 uint32 uint64`
- `float double`
- `Boolean`
- `Char String`

Из-за различий в базовых типах виртуальных машин базовые типы C# поддерживаются не полностью, поэтому поведение может отличаться.

#### Целочисленные типы в C#

`Int8 int16 int32 int64 uint8 uint16 uint32 uint64`

Все эти целочисленные типы поддерживаются по той причине, что NeoVM имеет только один целочисленный тип, реализованный на основе BigInteger. 

В базовой реализации числовой тип `VARINT` представлен как `BigInteger`.

Кроме того, перечисленные ниже операции поддерживаются для `BigInteger`：

```c#
ulong total_neo = 200;
BigInteger ico_neo = 300;
BigInteger balance_neo = total_neo - ico_neo;
ulong value = 150;
```

Обратите внимание: при преобразовании числового типа в меньший и при компилировании его в AVM значение (byte) (ulong) не округляется.

Математические операторы поддерживаются для всех целочисленных типов：

```c#
var a1 = abc + 1;
var a2 = abc - 1;
var a3 = abc * 1;
var a4 = abc / 1;
var a5 = abc % 2;
```

Логические операции поддерживаются для всех целочисленных типов：

```c#
if (a1 > a2) ;
if (a2 < a3) ;
if (a3 == a2) ;
if (a3 != a2) ;
if (a1 >= a2) ;
if (a1 <= a2) ;
```

Операторы инкремента поддерживаются для целочисленных значений：

```c#
int k = 100;
for (int j = 0; j < 3; j++)
{
   k += j;
}
```

#### Типы с плавающей точкой в C# 

Не поддерживаются.

#### Типы bool в C#

Базовая поддержка. На низком уровне поведение аналогично INT; false - это int 0.

#### Строковые и символьные типы в C#


Поддерживается не полностью. В отличие от строкового типа в C #, строковый тип в NeoVM обрабатывается как байтовый массив (bytearray), поэтому строка, скомпилированная в AVM, является на самом деле ее закодированным байтовым массивом UTF-8. Не используйте расширенные обработчики строк. Работайте со строковым типом как со специальным (в частности, не используйте строковый тип для обработки китайского языка).

```c#
string ss3 = "ab";
ss3 += "c";
var ss = "abcdef";
var b2 = ss.Length;
var c = ss + "abc";
var d = ss.Substring(1, 2);
```

Поддерживаются: конкатенация строк, взятие массива фиксированной длины (etch length) и операции intercept для байтов. Строки на английском языке поддерживаются так же, как строки в C#, однако строки на китайском не поддерживаются.

Поскольку другие типы, которые необходимо форматировать как строки, не поддерживаются, результаты `"abc"+1.ToString()` и C# отличаютс.

Тип char поддерживается как целочисленный тип.

#### Классы и структуры C#

Классы и структуры C# поддерживаются.


```c#
public class info
{
    public byte[] a;
    public byte[] b;
}
```

Определение пользовательских методов класса не поддерживается, за исключением внешних методов класса, которые используют такие функции, как APPCALL. 

Пользовательские конструкторы не поддерживаются, за исключением внешних конструкторов, которые используют атрибут OPCALL.

#### Массивы C# 

Массив C# поддерживается (поведение аналогично C#).

Byte[] является исключением, поскольку BytreArray является отдельным типом в NeoVM.

Как правило, вы можете задать значение в массиве, используя следующее:

```c#
short[] some= new short[17];
some[1] = 12;
return some;
```

#### Перечисления C# (Enumeration)

Определение перечислений поддерживается только в том случае, когда они используются как числовые значения.

Конвертация в String и из String не поддерживаются.

#### Контейнеры C#

Контейнеры List и Dictionary C#  не поддерживаются.

Функцию List можно заменить массивом. 

Функцию Dictionary можно заменить на MAP в NEO DOTNET DEVPACK.

#### Переменные C# 

Переменные не иемют ограничений. Определение констант и статических полей класса поддерживается. Присвоение начальных значений статическим полям класса поддерживается.

```c#
private const ulong total_neo = total_ico_usd / neo_to_usd * neo_decimals;
public static BigInteger TotalIcoNeo() => total_neo;
```

#### Делегаты и события C# 

Вы можете определить два вида делегатов C#, которые являются специальными функциями NeoVM.

 `public delegate void acall(string a);`

Одна из функций может быть использована для определения событий:

 `publics static event acall dododo;`

При вызове данного события компилятор NEO для C# считает его методом Notify. См. событие уведомления NEP5.

Другая функция может быть использована для преобразования байтового массива в делегат:

`acall call = (acall)new byte[] { 01, 02, 03 }.ToDelegate();`

Этот код вызывает смарт-контракт с указанным адресом. См. NEP4.

### Соглашения о разработке на C# 


#### Требования к export в C#

Компилятор NEO для C# требует, чтобы смарт-контракт имел только одну  функцию Main в качестве входной точки.

Другие экспортируемые функции должны быть публичными и статическими (public static) и иметь уникальное имя.

#### Определение делегатов в C#

Делегаты и события в C# обладают особыми функциями. См. раздел с делегатами и событиями C#.

Делегаты и события в C# соотносятся с нотификациями (notifications) смарт-контракта NEO и NEP4 соответственно.

#### Built-in-атрибуты

Вы можете обнаружить множество внешних (extern) функций NEO DEVPACK. На самом деле, они не имеют внешней реализации, поскольку их в принципе не нужно реализовывать.
 
Вы можете использовать данные функции в своем смарт-контракте.

#### APPCALL

Вызов функции с атрибутом APPCALL вызывает указанный смарт-контракт.

```c#
[Appcall("97b9373228d508155d5bdf75cd4703dfb1137fe0")]
public static extern bool AnotherContract(string arg, object[] args);
```

#### SYSCALL

Вызов функции с атрибутом Syscall вызывает соответствующую функцию системы:

```c#
 [Syscall("Neo.Account.GetBalance")]
  public extern long GetBalance(byte[] asset_id);
```

#### OPCALL

Когда происходит вызов функции с атрибутом OPCODE, данный вызов преобразуется в команду:

```c#
[OpCode(Neo.VM.OpCode.LEFT)]
public extern static byte[] Take(byte[] good, int index);
```

#### NONEMIT

Функция с атрибутом NonEmit выполняется обычно для приведения к корректному синтаксису. На самом деле, проводить преобразование в NeoVM нет никакой необходимости.

```c#
[Nonemit]
public extern static Delegate ToDelegate(this byte[] source);
```

#### NonemitWithConvert

Выполнение функции с атрибутом NonemitWithConvert фактически выполняет преобразование. Входные данные для этой функции должны быть константой, так как преобразование выполняется на этапе компиляции.

```c#
[NonemitWithConvert(ConvertMethod.ToScriptHash)]
public extern static byte[] ToScriptHash(this string address);
```

Например,  `"ASH……wk".ToScriptHash();` допустимо, поскольку компилятор может провести преобразование в "ABCD".

Однако,  `String xxx = "ASH……wk"; xxx.ToScriptHash();` недопустимо, поскольку компилятор не может определить значение XXX.

