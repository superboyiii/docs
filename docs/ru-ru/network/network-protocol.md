# Сетевой протокол


NEO использует сетевую структуру P2P, в которой узлы могут связываться друг с другом по протоколу TCP / IP. В данной структуре существуют два разных типа узлов: одноранговые узлы и узлы-валидаторы (именуемые буккиперами в Белой Книге NEO). Одноранговые узлы могут транслировать, принимать и передавать транзакции или блоки, в то время как узел-валидатор может только создавать блоки.


Сетевой протокол NEO в общем и целом похож на биткойновский, однако структуры данных, такие как блоки или транзакции, совершенно разные.

Convention
----

1. Порядок байтов

    Все целочисленные типы NEO имеют прямой порядок байтов, за исключением IP-адреса и номера порта, которые имеют обратный порядок байтов.

1. Хеш

   В NEO используются две разные хеш-функции: SHA256 и RIPEMD160. SHA256 применяется для генерации длинного хэш-значения, а RIPEMD160 - для генерации короткого хэш-значения. Как правило, мы получаем хэш-значение объекта, используя хеш-функцию дважды. Например, мы используем SHA256 два раза, когда хотим сгенерировать хэш-значение блока или транзакции. При создании адреса контракта мы сначала используем функцию SHA256, а затем - RIPEMD160.

   Кроме того, блок использует также хэш-структуру, называемую деревом Меркла. Оно вычисляет хэш каждой транзакции, объединяет их друг с другом, а затем снова хэширует и повторяет этот процесс до тех пор, пока не остается только один корневой хэш (корень дерева Меркла).

1. Тип переменной длины 

   + Variant: Целое число переменной длины, которое может быть закодировано, чтобы сэкономить место согласно введенному значению.

      |Значение|Длина|Формат|
      |---|---|---|
      |< 0xfd|1|uint8|
      |<= 0xffff|3|0xfd + uint16|
      |<= 0xffffffff|5|0xfe + uint32|
      |> 0xffffffff|9|0xff + uint64|

   + Varstr: Строка переменной длины, состоящая из целого числа переменной длины, за которым следуют строки. Строка закодирована UTF8.

      |Размер|Поле|Тип данных|Описание|
      |---|---|---|---|
      |?|length|variant|Длина строки в байтах|
      |length|string|uint8[length]|Сама строка|

   + Array: Массив состоит целого числа переменной длины, за которым следует последовательность элементов.

1. Число с фиксированной запятой

   Данные в NEO, такие как сумма или цена, - это 64-битное число с фиксированной запятой, при этом точность десятичной части равна 10<sup>-8</sup>, а диапазон составляет： [-2<sup>63</sup>/10<sup>8</sup>, +2<sup>63</sup>/10<sup>8</sup>)

Тип данных
-------

1. Blockchain

   Блокчейн является своего рода логической структурой, которая последовательно соединяется со списком, который поддерживает одностороннюю связь. Он используется для хранения данных всей сети, таких как транзакции или активы.

1. Block

   |Размер|Поле|Тип данных|Описание|
   |---|---|---|---|
   |4|Version|uint32|Версия блока (0 на данный момент)|
   |32|PrevBlock|uint256|Хэш-значение предыдущего блока|
   |32|MerkleRoot|uint256|Корневой хэш списка транзакций|
   |4|Timestamp|uint32|Временная метка|
   |4|Height|uint32|Высота блока|
   |8|Nonce|uint64|Случайное число|
   |20|NextMiner|uint160|Адрес контракта следующего майнера|
   |1|-|uint8|Фиксированный (1)|
   |?|Script|script|Скрипт, использующийся для валидации блока|
   |?*?|Transactions|tx[]|Список транзакций|

   При вычислении хэш-значения блока вместо вычисления всего блока будут вычислены только первые семь полей в начале блока (version, PrevBlock, MerkleRoot, timestamp и height, nonce, NextMiner). Поскольку MerkleRoot уже содержит хэш-значение всех транзакций, изменения в транзакции повлияют на хеш-значение блока.

   Структура данных начала блока:

   |Размер|Поле|Тип данных|Описание|
   |---|---|---|---|
   |4|Version|uint32|Версия блока (0 на данный момент)|
   |32|PrevBlock|uint256|Хэш-значение предыдущего блока |
   |32|MerkleRoot|uint256|Корневой хэш списка транзакций|
   |4|Timestamp|uint32|Временная метка|
   |4|Height|uint32|Высота блока|
   |8|Nonce|uint64|Случайное число|
   |20|NextMiner|uint160|Адрес контракта следующего майнера|
   |1|-|uint8|Фиксированный (1)|
   |?|Script|script|Скрипт, использованный для валидации блока|
   |1|-|uint8|Фиксированный 0|

   Временная метка каждого последующего блока должна быть позднее временной метки предыдущего блока. Обычно разница во временных метках двух блоков составляет около 15 секунд (неточность допускается). Высота блока должна быть равна высоте предыдущего блока плюс 1.

1. Transaction

   |Размер|Поле|Тип данных|Описание|
   |---|---|---|---|
   |1|Type|uint8|Тип транзакции|
   |1|Version|uint8|Trading версия (в данный момент 0)|
   |?|-|-|Данные, характерные для определенных типов транзакции|
   |?*?|Attributes|tx_attr[]|Дополнительные характеристики, которыми обладает транзакция|
   |34*?|Inputs|tx_in[]|Вход|
   |60*?|Outputs|tx_out[]|Выход|
   |?*?|Scripts|script[]|Список скриптов, использованных для валидации транзакции|

   Все процессы в системе NEO записываются как транзакции. Существует несколько типов транзакций:

   |Значение|Имя|Комиссия системы|Описание|
   |---|---|---|---|
   |0x00|MinerTransaction|0|Назначает побайтовую комиссию|
   |0x01|IssueTransaction|500\|0|Выпуск актива|
   |0x02|ClaimTransaction|0|Назначает GAS|
   |0x20|EnrollmentTransaction|1000|Enrollment for validator|
   |0x40|RegisterTransaction|10000|Assets register|
   |0x80|ContractTransaction|0|Contract transaction|
   |0xd0|PublishTransaction|500 * n|(Not usable) Special Transactions for Smart Contracts|
   |0xd1|InvocationTransaction|0|Special transactions for calling Smart Contracts|

   Each type of transaction, in addition to the public field, also has its own exclusive field. The following will describe these exclusive fields in detail.

   + MinerTransaction

      |Размер|Поле|Тип данных|Описание|
      |---|---|---|---|
      |4|Nonce|uint32|случайное число|

      Первая транзакция в каждом блоке должна быть MinerTransaction. Она используется для передачи всех комиссий по транзакциям текущего блока валидатору.

      Случайное число используется в транзакции для того, чтобы предотвратить столкновение хэшей.

   + IssueTransaction

      Для issue transaction не предусмотрено специальных полей.

      Управляющие активами могут создавать активы, которые были зарегистрированы в блокчейне NEO с помощью IssueTransaction, и отправлять их на любой адрес.

      В частности, если выпускаемые активы относятся к NEO, то транзакция будет отправлена ​​бесплатно.

      Случайное число используется в транзакции для того, чтобы предотвратить столкновение хэшей.

   + ClaimTransaction

      |Размер|Поле|Тип данных|Описание|
      |---|---|---|---|
      |34*?|Claims|tx_in[]|NEO, предназначенные для распределения|

   + EnrollmentTransaction

      |Размер|Поле|Тип данных|Описание|
      |---|---|---|---|
      |33|PublicKey|ec_point|открытый ключ валидатора|

      Транзакция представляет собой регистрационную форму, которая указывает на то, что спонсор транзакции хотел бы зарегистрироваться в качестве валидатора.

      Способ регистрации: Создать транзакцию типа EnrollmentTransaction и отправить депозит по адресу PublicKey.

      Чтобы отменить регистрацию, необходимо израсходовать депозит по адресу PublicKey.

   + RegisterTransaction

      > [!Warning]
      Был деактивирован и заменен на Neo.Asset.Create для смарт-контрактов.

      См. [Alternative .NET Smart Contract Framework](../sc/reference/fw/dotnet/neo/Asset/Create.md)

      См. [Alternative Smart Contract API](../sc/reference/api/neo.md)

   + ContractTransaction

      Для контрактной транзакции не существует особых атрибутов. Это очень распространенный вид транзакции, поскольку он позволяет отправлять NEO из одного кошелька в другой. Поля транзакции `inputs` и `outputs`  имеют, как правило, очень важное значение для данной транзакции (они, например, определяют, сколько NEO будет отправлено и на какой адрес).

   + PublishTransaction

      > [!Warning]
      Был деактивирован и заменен на Neo.Contract.Create для смарт-контрактов.

      См. [Alternative .NET Smart Contract Framework](../sc/reference/fw/dotnet/neo/Contract/Create.md)

      См. [Alternative Smart Contract API](../sc/reference/api/neo.md)

   + Invoking a Transaction

      | Размер | Поле | Тип данных | Описание |
      | ---- | ------ | ------- | --------------- |
      | -    | -      | -       | Открытые поля для транзакций          |
      | ?    | Script | uint8[] | Вызванный смарт-контрактом     |
      | 8    | Gas    | int64   | Стоимость выполнения смарт-контракта |
      | -    | -      | -       | Открытые поля для транзакций         |

1. Transaction Attributes

   |Размер|Поле|Тип данных|Описание|
   |---|---|---|---|
   |1|Usage|uint8|Использование|
   |0\|1|length|uint8|Длина данных (определенные условия в расчет не принимаются)|
   |length|Data|uint8[length]|Внешние данные|

   Иногда транзакция может содержать некоторые данные для внешнего использования. Эти данные будут помещены в поле атрибутов транзакций.

   Каждый атрибут транзакции имеет свое применение:

   |Значение|Имя|Описание|
   |---|---|---|
   |0x00|ContractHash|Хэш-значение контракта  |
   |0x02-0x03|ECDH02-ECDH03|Открытый ключ для обмена ключа ECDH |
   |0x20|Script|Дополнительная проверка транзакций |
   |0x30|Vote|Для голосования|
   |0x81|DescriptionUrl|Url-адрес описания|
   |0x90|Description|Краткое описание|
   |0xa1-0xaf|Hash1-Hash15|Используется для хранения  пользовательских  хэш-значений|
   |0xf0-0xff|Remark-Remark15|Комментарии|

   Для ContractHash, ECDH series, Hash series длина данных фиксирована и составляет 32 байта (поле длины в расчет не принимается);
   
   Для Script длина данных фиксирована и составляет 20 байт;
   
   Для DescriptionUrl длину данных необходимо устанавливать (длина не должна превышать 255 байт);

   Для Description, Remark series длину данных необходимо устанавливать (длина не должна превышать 65535 байт).

1. Input of Transaction

   |Размер|Поле|Тип данных|Описание|
   |---|---|---|---|
   |32|PrevHash|uint256|Хэш предыдущей транзакции |
   |2|PrevIndex|uint16|Индекс предыдущей транзакции|

1. Output of Transaction

   |Размер|Поле|Тип данных|Описание|
   |---|---|---|---|
   |32|AssetId|uint256|Id актива|
   |8|Value|int64|Значение|
   |20|ScriptHash|uint160|Адрес получателя перевода|

   Каждая транзакция может иметь до 65536 выходов.

1. Validation Script

   |Размер|Поле|Тип данных|Описание|
   |---|---|---|---|
   |?|StackScript|uint8[]|Код скрипта стека e|
   |?|RedeemScript|uint8[]|Код скрипта контракта|


   Скрипт стека может быть использован только для PUSH-операций, которые предназначены для перемещения данных, таких как подписи, в стек. Сначала интерпретатор скриптов выполняет код скрипта стека, а затем - код скрипта контракта.

   Хэш-значение кода скрипта контракта в транзакции должно соответствовать выводу транзакции (один из этапов верификации). Процесс выполнения скрипта детально описан в следующем разделе.


   Stack script can only be used for the PUSH operations, which is used to push data like signatures into the stack. The script interpreter will execute the stack script code first, and then execute the contract script code.

   In a transaction, the hash value of the contract script code must be consistent with the transaction output, which is part of the validation. The later section will describe the execution process of the script in detail.

Сообщения сети 
-------

Структура всех высылаемых сообщений сети выглядит следующим образом:

|Размер|Поле|Тип данных|Описание|
|---|---|---|---|
|4|Magic|uint32|ID протокола|
|12|Command|char[12]|Команда|
|4|length|uint32|Длина полезных данных|
|4|Checksum|uint32|Контрольная сумма|
|length|Payload|uint8[length]|Содержание сообщения|

Заданное Magic value:

|Значение|Описание|
|---|---|
|0x00746e41|Рабочий режим|
|0x74746e41|Тестовый режим|

Команда - это код utf8, длина которого составляет 12 байтов (в дополнительной части записывается 0).

Контрольная сумма - это первые 4 байта значения, равного двум хэшам SHA256 полезной нагрузки.

В зависимости от заказа полезная нагрузка имеет разный формат (см.ниже):

1. version

   |Размер|Поле|Тип данных|Описание|
   |---|---|---|---|
   |4|Version|uint32|Версия протокола (0 на данный момент)  |
   |8|Services|uint64|Сервис, предоставляемый узлом, равен  в данный момент 1 |
   |4|Timestamp|uint32|Текущее время|
   |2|Port|uint16|Порт, который сервер listening on (равен 0, если не используется).|
   |4|Nonce|uint32|Используется для того, чтобы отличить узел от открытого IP|
   |?|UserAgent|varstr|ID клиента|
   |4|StartHeight|uint32|Высота блокчейна|
   |1|Relay|bool|Или получить, или переслать|


   Когда узел получает запрос на соединение, он немедленно объявляет свою версию. Дальнейшая коммуникация будет невозможна, пока обе стороны не получат версии друг друга.

1. verack

   Когда узел получает сообщение о версии, он немедленно высылает в ответ verack.
   
   Данное сообщение не имеет полезных данных.

1. getaddr

   Запрашивает у узла пакет новых активных узлов, чтобы увеличить число соединений
   
   Данное сообщение не имеет полезных данных.

1. addr

   |Размер|Поле|Тип данных|Описание|
   |---|---|---|---|
   |30*?|AddressList|net_addr[]|Адрес других узлов в сети |

   После получения сообщения getaddr узел возвращает в ответ сообщение addr и предоставляет информацию об известных узлах в сети.

1. getheaders

   |Размер|Поле|Тип данных|Описание|
   |---|---|---|---|
   |32*?|HashStart|uint256[]|Хэш нового блока, который запрашивает узел|
   |32|HashStop|uint256|Хэш предыдущего блока, который запрашивает узел|

   Запрашивает у узла пакеты заголовков не более 2000 блоков, содержащих HashStart и HashStop. Чтобы получить после этого хэш блока, вам необходимо повторно отправить сообщение getheaders. Данное сообщение используется для быстрой загрузки блокчейна, который не содержит транзакции.

1. headers

   |Размер|Поле|Тип данных|Описание|
   |---|---|---|---|
   |?*?|Headers|header[]|Заголовок блока|

   После получения сообщения getheaders узел возвращает в ответ сообщение header и предоставляет информацию об известных узлах в сети.

1. getblocks

   |Размер|Поле|Тип данных|Описание|
   |---|---|---|---|
   |32*?|HashStart|uint256[]|Хэш последнего блока, который запрашивает узел|
   |32|HashStop|uint256|Хэш начального блока, который запрашивает узел|

   Запрашивает у узла сообщение inv, которое начинается с HashStart и заканчивается HashStop. Число блоков, которые начинаются с HashStart и заканчивается HashStop, не превышает 500. Если вы хотите получить больше хэшей блоков, то вам необходимо отправить сообщение getblocks повторно.

1. inv

   |Размер|Поле|Тип данных|Описание|
   |---|---|---|---|
   |36*?|Inventories|inv_vect|Дата  инвентаризаций|

   Узел может транслировать информацию об объекте, которым он владеет, с помощью данного сообщения. Сообщение может быть отправлено автоматически или в ответ на сообщения getblocks.

   Информация об объекте включена в список:

   |Размер|Поле|Тип данных|Описание|
   |---|---|---|---|
   |4|Type|uint32|Тип объекта|
   |32|Hash|uint256[]|Хэш объектов|

   Object types:

   |Значение|Имя|Описание|
   |---|---|---|
   |0x01|TX|Транзакция|
   |0x02|Block|Блок|
   |0xe0|Consensus|Данные консенсуса|

1. getdata

   |Размер|Поле|Тип данных|Описание|
   |---|---|---|---|
   |36*?|Inventories|inv_vect[]|Дата инвентаризаций|

   Запросить указанный объект из узла: он обычно высылается после того, как получен пакет inv, а известный элемент удален.

1. block

   |Размер|Поле|Тип данных|Описание|
   |---|---|---|---|
   |?|Block|block|Блок|

   Высылает блок узлу в ответ на сообщение getdata.

1. tx

   |Размер|Поле|Тип данных|Описание|
   |---|---|---|---|
   |?|Transaction|tx|Транзакция|
   
   Высылает транзакцию узлу в блок в ответ на сообщение getdata.

   |Размер|Поле|Тип данных|Описание|
   |----|---------|--------- |----------------- |
   |32 *?|HashStart|uint256[]|Узел известен как хэш последнего блока |
   |32|hashStop|uint256|Запрашивает последний блок|
